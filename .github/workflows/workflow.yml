name: Building and Testing

#on:
#  push:
#  pull_request:
#    types:
## https://help.github.com/en/actions/reference/events-that-trigger-workflows#pull-request-event-pull_request
#      - opened
#      - synchronize
#      - reopened
#      - closed
#    branch:
#      - master

jobs:
  build_test_and_maybe_release:
    runs-on: ubuntu-latest
    env:
      DO_RELEASE: false
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update
          # build-essential is already installed:
          # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/software-installed-on-github-hosted-runners#ubuntu-1804-lts
          sudo apt-get install luajit
          # It's unlikely an existing lua interpreter is installed, but this does set up the idea
          # of how I'd have multiple lua interpreters installed, and switch between them for
          # matrix job runs, if that ever needs to happen
          # Alternatively, I could manually symlink luajit to lua
          sudo update-alternatives --install /usr/bin/lua lua-interpreter "$(which luajit)" 120
          sudo update-alternatives --set lua-interpreter "$(which luajit)"
          # Install luarocks after LuaJIT, just in case it gets funny with installing its own interpreter
          # and configuring itself for that one
          sudo apt-get install luarocks --no-install-recommends
          eval $(luarocks path | tee -a ~/.bashrc)
          # Set the variables to persist
          echo "::set-env name=LUA_PATH::${LUA_PATH}"
          echo "::set-env name=LUA_CPATH::${LUA_CPATH}"

      - name: Download list of LuaCov releases; save luarocks version
        run: |
          curl -L https://api.github.com/repos/keplerproject/luacov/tags > luacov_releases.json
          luarocks --version > luarocks_version

      # Apparently, if there's no cache for this key, the action will wait untilt he end of the run
      # and save the stuff in the path under the key as a new cache:
      # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/caching-dependencies-to-speed-up-workflows#using-the-cache-action
      - name: Cache install dependencies
        id: cache
        uses: actions/cache@v1.1.0
        with:
          # A directory to store and save the cache
          path: ~/.luarocks
          # An explicit key for restoring and saving the cache
          key: ${{ runner.os }}-luarocks-${{ hashFiles('luacov_releases.json') }}-${{ hashFiles('luarocks_version') }}
          # An ordered list of keys to use for restoring the cache if no cache hit occurred for key
          #restore-keys: # optional

      - name: Build cluacov if it's not in the cache
        # https://github.com/actions/cache#Skipping-steps-based-on-cache-hit
        if: steps.cache.outputs.cache-hit != "true"
        run: |
          luarocks install cluacov
          # https://stackoverflow.com/a/11621788/5059062
          eval $(echo 'export PATH="${PATH}:$(dirname ~/.luarocks/bin/luacov)"' | tee -a ~/.bashrc)
          echo "::set-env name=PATH::${PATH}"
      
      - name: Remove version files
        run: rm luarocks_version luacov_releases.json

      - name: Build and run tests
        # "The workspace directory contains a subdirectory with a copy of your repository if your workflow uses the actions/checkout action."
        # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
        # Also: https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context
        # Decribed somewhere in here:
        # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsrun
        working-directory: ./src
        run: |
          lua -lluacov -e "test=1 build=1" build.lua
          luacov

      - name: Upload test coverage to codecov.io
        uses: codecov/codecov-action@master
        with:
          token: ${{ secrets.CODECOV_TOKEN }} #required
          file: ./src/luacov.report.out #optional
          #flags: tests #optional
          #name: codecov-umbrella #optional
          #yml: ./codecov.yml #optional
          fail_ci_if_error: true #optional (default = false)
      
      - name: Did this action execute because of a merged pull request with a tag, signed by the repo owner, pointing to the new merge commit?
        # We first test if this is a pull_request being closed, and if the closer is the repo owner
        # I am using the example data structure here: https://developer.github.com/v3/pulls/#response
        if: github.event_name == "pull_request" && github.event.author_association == "OWNER" && github.event.merged == "true"
        # Then we confirm that a tag, signed by the author, points to this merged commit
        run: |
          # First, we need to find the tag signer's PGP key ID
          # Then we download that signer's PGP key ID
          # Then we verify the tag author's email is in the PGP key's list of IDs
          # Finally, we confirm the tag signature is valid, and set the environment
          # vaariable for the following workflow steps if it is
          export TAG_NAME="$(git describe --exact-match --match "v*")"
          git tag -v "${TAG_NAME}" && \
            echo "::set-env name=DO_RELEASE::true"

      - name: Bump version if not already bumped
        if: env.DO_RELEASE
        working-directory: ./src
        run: |
          lua -e "bumpversion=1" build.lua
        
      - name: Move `release` commit to `v...`, pointing to a commit that includes the built SpecialSounds.lua and version-bumped header.lua
