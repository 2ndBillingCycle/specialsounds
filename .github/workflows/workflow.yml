name: Building and Testing

on:
  push:
  pull_request:
    types:
# https://help.github.com/en/actions/reference/events-that-trigger-workflows#pull-request-event-pull_request
      - opened
      - synchronize
      - reopened
      - closed
    branch:
      - master

jobs:
  build_test_and_maybe_release:
    runs-on: ubuntu-latest
    env:
      DO_RELEASE: false
    steps:
      - name: Install dependencies
        run: |
          sudo apt-get update
          # build-essential is already installed:
          # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/software-installed-on-github-hosted-runners#ubuntu-1804-lts
          sudo apt-get install luajit
          # It's unlikely an existing lua interpreter is installed, but this does set up the idea
          # of how I'd have multiple lua interpreters installed, and switch between them for
          # matrix job runs, if that ever needs to happen
          # Alternatively, I could manually symlink luajit to lua
          sudo update-alternatives --install /usr/bin/lua lua-interpreter "$(which luajit)" 120
          sudo update-alternatives --set lua-interpreter "$(which luajit)"
          # Install luarocks after LuaJIT, just in case it gets funny with installing its own interpreter
          # and configuring itself for that one
          sudo apt-get install luarocks --no-install-recommends
          eval $(luarocks path | tee -a ~/.bashrc)
          # Set the variables to persist
          echo "::set-env name=LUA_PATH::${LUA_PATH}"
          echo "::set-env name=LUA_CPATH::${LUA_CPATH}"

      - name: Download list of LuaCov releases; save luarocks version
        run: |
          curl -L https://api.github.com/repos/keplerproject/luacov/tags > luacov_releases.json
          luarocks --version > luarocks_version

      # Apparently, if there's no cache for this key, the action will wait untilt he end of the run
      # and save the stuff in the path under the key as a new cache:
      # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/caching-dependencies-to-speed-up-workflows#using-the-cache-action
      - name: Cache install dependencies
        id: cache
        uses: actions/cache@v1.1.0
        with:
          # A directory to store and save the cache
          path: ~/.luarocks
          # An explicit key for restoring and saving the cache
          key: ${{ runner.os }}-luarocks-${{ hashFiles('luacov_releases.json') }}-${{ hashFiles('luarocks_version') }}
          # An ordered list of keys to use for restoring the cache if no cache hit occurred for key
          #restore-keys: # optional

      - name: Build cluacov if it's not in the cache
        # https://github.com/actions/cache#Skipping-steps-based-on-cache-hit
        if: steps.cache.outputs.cache-hit != "true"
        run: |
          luarocks install cluacov
          # https://stackoverflow.com/a/11621788/5059062
          eval $(echo 'export PATH="${PATH}:$(dirname ~/.luarocks/bin/luacov)"' | tee -a ~/.bashrc)
          echo "::set-env name=PATH::${PATH}"
      
      - name: Remove version files
        run: rm luarocks_version luacov_releases.json

      - name: Build and run tests
        # "The workspace directory contains a subdirectory with a copy of your repository if your workflow uses the actions/checkout action."
        # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
        # Also: https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context
        # Decribed somewhere in here:
        # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsrun
        working-directory: ./src
        run: |
          lua -lluacov -e "test=1 build=1" build.lua
          luacov

      - name: Upload test coverage to codecov.io
        uses: codecov/codecov-action@master
        with:
          token: ${{ secrets.CODECOV_TOKEN }} #required
          file: ./src/luacov.report.out #optional
          #flags: tests #optional
          #name: codecov-umbrella #optional
          #yml: ./codecov.yml #optional
          fail_ci_if_error: true #optional (default = false)
      
      - name: Did this action execute because of a merged pull request with a tag, signed by the repo owner, pointing to the new merge commit?
        # We first test if this is a pull_request being closed, and if the closer is the repo owner
        # I am using the example data structure here: https://developer.github.com/v3/pulls/#response
        if: github.event_name == "pull_request" && github.event.author_association == "OWNER" && github.event.merged == "true"
        # Then we confirm that a tag, signed by the author, points to this merged commit
        run: |
					# We're using jq and curl to interact with the GitHub API:
					# https://stedolan.github.io/jq/
					# https://curl.haxx.se/docs/manpage.html
					sudo apt-get install -y jq curl

          # First, we download the PGP key GitHub has for the repo owner
          curl -sq https://api.github.com/users/${{ github.event.head.repo.owner.login }}/gpg_keys | \
            jq -r ".[0].raw_key" | \
            gpg --import
          # Then we confirm the tag signature is valid, and set the environment
          # variable for the following workflow steps if it is
          git describe --exact-match --match 'v*'
          git tag -v "$(git describe --exact-match --match 'v*' --abbrev=0)" && \
            echo "::set-env name=DO_RELEASE::true"

      - name: Does the tag name match the current version in header.lua?
        if: env.DO_RELEASE
        working-directory: ./src
        run: |
          lua - "$(git describe --exact-match --match 'v*' --abbrev=0)" <<EOF
          local header = require "header"
          if header.version ~= arg[1] then
            error("Current version in header.lua does not match the tag name")
          end
          EOF

      - name: Grab most recent tag name and message
        run: |
          export TAG_NAME="$(git describe --match 'v*' --abbrev=0)"
          # Multiline: https://github.com/actions/starter-workflows/issues/68#issuecomment-581479448
          export TAG_MESSAGE=$(git log -n 1 --format="%B" --no-notes ${TAG_NAME} | sed -e 's/\n/%0A/g')
          echo "::set-env name=TAG_NAME::${TAG_NAME}"
          echo "::set-env name=TAG_MESSAGE::${TAG_MESSAGE}"

      - name: Make release
        if: env.DO_RELEASE
        id: make_release
        uses: action/create-release@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.TAG_NAME }}
          release_name: ${{ env.TAG_NAME }}
          body: ${{ env.TAG_MESSAGE }}
          draft: false
          prerelease: false

      - name: Add the built SpecialSounds.lua to the release as an asset
        if: env.DO_RELEASE
        id: upload_asset
        uses: action/upload-release-asset@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.make_release.outputs.upload_url }}
