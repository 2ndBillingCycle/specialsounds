name: Build and test

on:
  push:
    paths-ignore:
      - README.md
      - CODE_OF_CONDUCT.md
      - LICENSE
      - "docs/**"
  pull_request:
    types:
# https://help.github.com/en/actions/reference/events-that-trigger-workflows#pull-request-event-pull_request
      - opened
      - synchronize
      - reopened
      - closed
    branch:
      - master

jobs:
  build_test_and_maybe_release:
    runs-on: ubuntu-latest
    env:
      DO_RELEASE: false
    steps:
      - name: Install dependencies
        run: |
          # This returned an error on two separate runs:
          # sudo apt-get update
          # https://github.com/2ndBillingCycle/specialsounds/runs/459091758?check_suite_focus=true#step:2:63
          # build-essential is already installed:
          # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/software-installed-on-github-hosted-runners#ubuntu-1804-lts
          sudo apt-get install --no-install-recommends luajit luarocks
          sudo update-alternatives --install /usr/bin/lua lua-interpreter "$(which luajit)" 120
          sudo update-alternatives --set lua-interpreter "$(which luajit)"
          eval $(luarocks path | tee -a ~/.bashrc)
          # Set the variables to persist
          echo "::set-env name=LUA_PATH::${LUA_PATH}"
          echo "::set-env name=LUA_CPATH::${LUA_CPATH}"

      # Manually doing a hash, as it seems https://github.com/actions/cache/issues/39#issuecomment-552252932 is still affecting me:
      # https://github.com/2ndBillingCycle/specialsounds/runs/461221650?check_suite_focus=true#step:5:10
      - name: Download list of LuaCov releases and concatenate with luarocks version for a hash for cacheing
        run: |
          curl -L https://api.github.com/repos/keplerproject/luacov/tags > luacov_releases.json
          luarocks --version > luarocks_version
          echo "::set-env name=FILE_HASH_FOR_CACHE::$(cat luacov_releases.json luarocks_version | sha256sum | grep -Eo '\w+')"
          rm luacov_releases.json luarocks_version

      # Apparently, if there's no cache for this key, the action will wait until the end of the run
      # and save the stuff in the path under the key as a new cache:
      # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/caching-dependencies-to-speed-up-workflows#using-the-cache-action
      - name: Cache build and testing dependencies
        id: cache
        uses: actions/cache@v1.1.0
        with:
          # A directory to store and save the cache
          path: ~/.luarocks
          # An explicit key for restoring and saving the cache
          key: ${{ runner.os }}-luarocks-${{ env.FILE_HASH_FOR_CACHE }}
          # An ordered list of keys to use for restoring the cache if no cache hit occurred for key
          #restore-keys: # optional

      - name: Build dependencies for luacov if they're not in the cache
        # https://github.com/actions/cache#Skipping-steps-based-on-cache-hit
        if: steps.cache.outputs.cache-hit != 'true'
        run: |
          luarocks install --local cluacov
          luarocks install --local luafilesystem # Needed for luacov: includeuntestedfiles

      - name: Set luacov path
        run: |
          # https://help.github.com/en/actions/reference/development-tools-for-github-actions#add-a-system-path-add-path
          # https://stackoverflow.com/a/11621788/5059062
          echo "::add-path::$(dirname ~/.luarocks/bin/luacov)"
      
      # This, by default, checks out 1 commit, and sets up git with the GITHUB_TOKEN
      - name: Checkout repository
        uses: actions/checkout@master

      - name: Build and run tests
        # "The workspace directory contains a subdirectory with a copy of your repository if your workflow uses the actions/checkout action."
        # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/using-environment-variables#default-environment-variables
        # Also: https://help.github.com/en/actions/automating-your-workflow-with-github-actions/contexts-and-expression-syntax-for-github-actions#github-context
        # Decribed somewhere in here:
        # https://help.github.com/en/actions/automating-your-workflow-with-github-actions/workflow-syntax-for-github-actions#jobsjob_idstepsrun
        working-directory: ./src
        run: |
          # Whether test or build is run first is determined inside the script,
          # not by the ordering of arguments
          lua -lluacov build.lua test build
          luacov

      - name: Upload test coverage to codecov.io
        uses: codecov/codecov-action@master
        with:
          token: ${{ secrets.CODECOV_TOKEN }} #required
          file: ./src/luacov.report.out #optional
          #flags: tests #optional
          #name: codecov-umbrella #optional
          yml: ./codecov.yml #optional
          fail_ci_if_error: true #optional (default = false)
      
      - name: Did this action execute because of a merged pull request with a tag, signed by the repo owner, pointing to the new merge commit?
        # We first test if this is a pull_request being closed, and if the closer is the repo owner
        # I am using the example data structure here: https://developer.github.com/v3/pulls/#response
        if: github.event_name == 'pull_request' && github.event.author_association == 'OWNER' && github.event.merged == 'true'
        # Then we confirm that a tag, signed by the author, points to this merged commit
        run: |
          # We're using jq and curl to interact with the GitHub API:
          # https://stedolan.github.io/jq/
          # https://curl.haxx.se/docs/manpage.html
          sudo apt-get install -y jq curl

          # First, we download the PGP key GitHub has for the repo owner
          curl -sq https://api.github.com/users/${{ github.event.head.repo.owner.login }}/gpg_keys | \
            jq -r ".[0].raw_key" | \
            gpg --import
          # Then we confirm that this commit is pointed to by an annotated
          # tag with a name that begins with v, and that the tag signature
          # is valid, and set the environment variable for the following workflow steps if it is
          git describe --exact-match --match 'v*' && \
            git tag -v "$(git describe --exact-match --match 'v*' --abbrev=0)" && \
            echo "::set-env name=DO_RELEASE::true" || \
            echo "::set-env name=DO_RELEASE::false"

      - name: Does the tag name match the current version in header.lua?
        if: env.DO_RELEASE == 'true'
        working-directory: ./src
        run: |
          lua - "$(git describe --exact-match --match 'v*' --abbrev=0)" <<EOF
          local header = require "header"
          if header.version ~= arg[1] then
            err_str = "Current version in header.lua does not match the tag name"
            print("::error::"..err_str)
            error(err_str)
          end
          EOF

      - name: Grab most recent tag name and message
        if: env.DO_RELEASE == 'true'
        run: |
          export TAG_NAME="$(git describe --match 'v*' --abbrev=0)"
          # Multiline: https://github.com/actions/starter-workflows/issues/68#issuecomment-581479448
          export TAG_MESSAGE=$(git log -n 1 --format="%B" --no-notes ${TAG_NAME} | sed -e 's/\n/%0A/g')
          echo "::set-env name=TAG_NAME::${TAG_NAME}"
          echo "::set-env name=TAG_MESSAGE::${TAG_MESSAGE}"

      - name: Make release
        if: env.DO_RELEASE == 'true'
        id: make_release
        uses: actions/create-release@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          tag_name: ${{ env.TAG_NAME }}
          release_name: ${{ env.TAG_NAME }}
          body: ${{ env.TAG_MESSAGE }}
          draft: false
          prerelease: false

      - name: Add the built SpecialSounds.lua to the release as an asset
        if: env.DO_RELEASE == 'true'
        id: upload_asset
        uses: actions/upload-release-asset@master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        with:
          upload_url: ${{ steps.make_release.outputs.upload_url }}
